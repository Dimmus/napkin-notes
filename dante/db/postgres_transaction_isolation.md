# PostgreSQL Transaction Isolation Testing in Rails apps

## Covered Topics

This note will examine only `Repeatable Read` (the default) and `Serializable` isolation levels.
`DELETE` statements were also not tested.

## Definitions

`Record` is some `ActiveRecord` class, while `record` is an instance of the `Record` class.

`Advisory locks` are locks provided by PostgreSQL that can be used by the application
at the application's discretion. PostgreSQL provides commands for acquiring the lock
(blocking and non-blocking) and only one connection (process/thread) can hold each lock at a time.
We recommend using the Procore fork of the `with_advisory_lock` gem at
https://github.com/procore/with_advisory_lock so that advisory locks
are automatically released when transactions end.

### PostgreSQL Errors

In this note, we will refer to 2 PostgreSQL errors:
`ERROR:  could not serialize access due to concurrent update`
will be called a `transaction isolation error`.
This error will generate an `ActiveRecord::TransactionIsolationConflict` exception in Rails,
which will cause the transaction to be retried with the `transaction_retry` gem.

`ERROR:  duplicate key value violates unique constraint "name"`
will be called a `uniqueness constraint violation`.
This error will generate an `ActiveRecord::RecordNotUnique` exception in Rails,
which will NOT cause the transaction to be retried with the `transaction_retry` gem.

## Rails SQL statements refresher

This section is a quick refresher of what SQL is generated by each Rails persistence command.

`Record.find` and `Record.where(sth).first` with no other modifiers use simple `SELECT` statements.

Both `Record.where(sth).lock.first` and `record.lock!` will use a `SELECT FOR UPDATE`.
However, using `.lock!` (on a record, not a relation) causes a reload,
which uses one extra query compared to `.lock`.

`Record.create` and `record.save` (on a new record) both use `INSERT` statements.

`record.save` (on a persisted record), `record.update_attribute` and `record.update_attributes`
all use `UPDATE` statements.

`record.touch` uses an `UPDATE` statement to update only the record's timestamps.

Finally, `record.destroy` and `record.delete` use `DELETE` statements.

## Rails transactions

`Record.transaction do` will initiate a simple transaction
in the database that contains the table for the `Record` class (in case multiple DB's are in use).
By default, `PostgreSQL` uses the `REPEATABLE READ` isolation level.
The transaction can be retried with the `retry` command and
will automatically commit when the block ends.

`Record.isolation_level(:serializable) do` allows you to initiate a `SERIALIZABLE`
transaction, provided the `transaction_isolation` gem is loaded.

Finally, `record.with_lock do` will initiate a transaction, then reload `record` with `.lock!`.
This is slightly inefficient compared to using a simple transaction
and loading the record for the first time in it with `.lock`.

## Interactions between different SQL statements

Unless otherwise noted, the following interactions will happen in transactions
with any of the 2 tested isolation levels (`REPEATABLE READ` or `SERIALIZABLE`):

### SELECT FOR UPDATE and UPDATE

`SELECT FOR UPDATE` `blocks` other `SELECT FOR UPDATE` in the same row
in other transactions if and only if the row exists to begin with.
`SELECT` statements seem unaffected by `SELECT FOR UPDATE`.

`UPDATE`ing the row selected with `SELECT FOR UPDATE` in one transaction
will cause a `transaction isolation error` in the other transaction
as soon as the `SELECT FOR UPDATE` returns (despite the blocking read).

If no update is actually performed in the row where `SELECT FOR UPDATE` was used,
but different rows are updated, other transactions will succeed, possibly with stale data
(despite the blocking read).
In this case, it might be desirable to use `SELECT FOR UPDATE` on rows that are actually `UPDATE`d
or to `.touch` the record to force an `UPDATE` (or use an advisory lock instead).

### INSERT

`INSERT`s usually do not conflict unless they violate a uniqueness constraint,
in which case a `uniqueness constraint violation` will be immediately returned.

If there is `INSERT` contention (for example, due to `find_or_create`),
one way to do it is to patch `transaction_retry` to also retry `ActiveRecord::RecordNotUnique`,
as done in https://github.com/openstax/exchange/blob/master/lib/transaction_retry_patch.rb.
If you do apply this patch, you should ensure that the record also has the corresponding uniqueness
validation on the application side, to prevent unnecessary retries on failing transactions.

If there is too much `INSERT` contention, an `advisory lock` can be used
to prevent the maximum number of transaction retries from being exceeded.

## Differences between PostgreSQL isolation levels

So what do the PostgreSQL `REPEATABLE READ` and `SERIALIZABLE` isolation levels actually do?

### REPEATABLE READ (the default)

Different transactions are allowed to `UPDATE` the same row without causing an error.
This can be a bad thing if the first `UPDATE` should have affected the second.
`SELECT FOR UPDATE` can be used to mitigate this,
since its behavior (described in the previous section) does not depend on the isolation level.

### SERIALIZABLE

An `UPDATE` will cause a `transaction isolation error` in other transactions
that also `UPDATE` the same row, making them retry.

Both `SELECT FOR UPDATE` and `INSERT` seem unaffected by the `SERIALIZABLE` isolation level.

However, `Serializable` isolation incurs a lot of extra overhead:
If there is any sort of contention for rows, transactions will routinely fail
(and retry with the `transaction_retry` gem), reducing application throughput.
Finally, if the maximum number of retries is exceeded, the transaction will fail with an error.

## Summary of key findings

- Use the `transaction_retry` gem. Transactions are meant to fail and be retried sometimes.

- To prevent 2 transactions from updating the same record with stale data, `.lock`
  is probably the easiest and fastest option.

- If the locked record does not require an update (but other records do),
  you must either `.touch` the `.lock`ed record or use an `advisory lock` instead.

- `INSERT` contention (`find_or_create`) can only be solved with an `advisory lock`
  or a patch to the `transaction_retry` gem.
